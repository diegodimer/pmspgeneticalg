\documentclass[10pt]{scrartcl}
%\documentclass[a4paper,10pt]{paper}

\usepackage[english,portuges]{babel}
%\usepackage[latin1]{inputenc}
\usepackage{fancyhdr}
\usepackage[nofancy]{svninfo}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage[all]{xy}
\usepackage{ifdraft}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
%\usepackage[utf8x]{inputenc}
\usepackage[top=2cm,left=2cm,right=2cm,bottom=2cm]{geometry}
\usepackage{indentfirst}
\usepackage{amsfonts, amsmath, amssymb}
%\usepackage[brazil]{babel}
%\usepackage[T1]{fontenc}%codificação
\usepackage{graphicx,color}
\usepackage{comment}
\usepackage{amssymb}
\usepackage{ifthen}

\parindent0pt

\lhead{\small Universidade Federal do Rio Grande do Sul\\
Instituto de Informática\\
Departamento de Informática Teórica}
\rhead{\small INF05510 -- Otimização Combinatória\\
Profa. Luciana S. Buriol\\}


\begin{document}

\newboolean{showComments}
%mostrar comentarios
%\setboolean{showComments}{true}
\setboolean{showComments}{false}


\begin{center}
  \Large
  \setlength{\fboxsep}{1em}\setlength{\fboxrule}{0pt}
\fbox{%
{ Aplicação do Algoritmo Genético ao Parallel Machines Scheduling Problem}%
}
\normalsize 
Diego Dimer, Eduardo Paim, Gabriel Tadiello \\
 
\end{center}

\pagestyle{fancy}

\medskip
\section{Problema}

\subsection{O que é}
O problema do escalonamento em máquinas paralelas com tempo de setup consiste em escalonar N tarefas (1, ..., n) uma única vez em alguma das M máquinas (1, ..., m). A solução consiste da ordem de atribuição das tarefas em cada máquina, com o objetivo de minimizar o \textit{makespan}: tempo para completar todas as tarefas paralelamente. São dados de entrada do problema o número de máquinas e tarefas, além do tempo de processamento $P_{jk}$ da tarefa j na máquina k e o tempo de setup $S_{ijk}$, representando o tempo necessário de setup para realizar tarefa j após a tarefa i na máquina k. Com os dados $S_{ijk} e P_{jk}$ montamos a matriz $G_{ijk}$, onde $G_{ijk}=S_{ijk}+P_{jk}$, necessária na formulação do problema.

\subsection{Programação Linear Inteira Mista}
Antes de implementar a meta-heurística desenvolvida nesse trabalho foi feita a formulação matemática em Programação Linear Inteira Mista, com função objetivo de minimizar o tempo máximo entre todas as máquinas. A formulação, no entanto, só é eficaz para pequenas instâncias do problema, já que PILM tende a consumir muitos recursos computacionais conforme a instância cresce.
O problema foi formulado da seguinte maneira:
 $j = 1, ..., n$  tarefas \\ $i = 0, ..., n$ tarefas mais tarefa \textit{"dummy"} em $i_0$\\ $k = 1, ..., m$ máquinas

\begin{align}
  \textbf{min} \qquad & C_{max} \label{pilm: fo}\\ 
  \textbf{sujeito a}\qquad
  & \sum_{k=1}^{m} \sum_{\substack{i=0 \\ i\neq j}}^{n} x_{ijk} = 1 &&\forall j \label{pilm: R1}\\
  & \sum_{\substack{i=0 \\ i\neq h}}^{n}x_{ihk} - \sum_{\substack{j=0 \\ j\neq h}}^{n}x_{hjk} = 0 && \forall h,k \label{pilm: R2}\\
  & c_i + \sum_{k=1}^{m}x_{ijk} G_{ijk} + V ( (\sum_{k=1}^{m}x_{ijk}) - 1) \leq c_j && \forall i,j \label{pilm: R3}\\
  & c_j \leq c_{max} && \forall j \label{pilm: R4}\\
  & \sum_{j=1}^{n}x_{0jk} = 1 && \forall k  \label{pilm: R5}\\
  & c_j \geq 0 && \forall j \label{pilm: R6}\\
  & c_0 = 0 \label{pilm: R7}\\
  & x_{ijk} \geq 0 && \forall i,j,k \label{pilm: R8} 
\end{align}
onde:\\
$c_{max}$: tempo total de completar o escalonamento da máquina mais demorada \textit{(makespan)} \\
$c_j$: tempo para completar o job j\\
$G_{ijk}$: tempo de processamento e setup para executar o job j após o job i na máquina k \\
$x_{ijk}$: 1 se job j é escalonado diretamente após job i na máquina k, 0 caso contrário \\
$x_{0jk}$: 1 se job j é o primeiro job escalonado na máquina k, 0 caso contrário \\
$x_{j0k}$: 1 se job j é o último job escalonado na máquina k, 0 caso contrário \\
$n$: número de jobs \\
$m$: número de máquinas \\
$V$: número inteiro muito grande \\ \\
\textbf{Notas:} A função objetivo em (\ref{pilm: fo}) é minimizar o tempo máximo que as máquinas demorariam para processar todas as tarefas. A restrição em (\ref{pilm: R1}) serve para garantir que cada tarefa é executada apenas uma vez e apenas em uma máquina. A restrição em (\ref{pilm: R2}) assegura que cada tarefa tenha uma tarefa antecedendo e precedendo ela se ela for executada na máquina k. A restrição (\ref{pilm: R3}) é usada para acumular na variável $c_i$ o tempo de execução daquela máquina (explica-se, por essa restrição, a necessidade de uma tarefa \textit{"dummy"} com tempo de completar em 0 (\ref{pilm: R7})). A restrição (\ref{pilm: R4}) garante que $c_{max}$ é sempre o maior entre os $c_j$. Em (\ref{pilm: R5}) garantimos que cada máquina começa com uma tarefa e apenas uma (não há necessidade pela restrição em (\ref{pilm: R3}) de se fazer o mesmo para última tarefa. Em (\ref{pilm: R6}) e (\ref{pilm: R8}) garanta-se que as variáveis não vão assumir valores negativos (além da restrição omitida de que elas sejam inteiras).\\

\subsection{Exemplo}


\section{Meta-Heurística}
Para implementação da meta-heurística foi usado algoritmo genético, escrito na linguagem de programação python. Devido ao grande número de variações do algoritmo, como tamanho de população, modos de reprodução e mutação, optamos por fazer o tamanho da população ser igual a soma de todas as mutações e reproduções feitas no algoritmo, por exemplo: população de tamanho 10, com 5 elementos sofrendo mutação de um ponto e 5 sofrendo reprodução. 
\subsection{Algoritmo Genético}

\subsection{Escolha dos parâmetros}

\subsection{Representação da Solução}
A função objetivo do problema é minimizar o tempo de executar todas as tarefas alocadas a máquina que demora mais tempo para terminar, para isso utilizamos (na formulação) uma variável $c$, onde a ordem de alocação das tarefas nas máquinas é representada pela variável $x$. Para a meta-heurística, foi necessário definir uma representação de solução que indique a ordem de execução das n tarefas nas m máquinas, para isso utilizamos uma matriz (em python utilizamos uma lista de listas), onde cada linha representa uma máquina e cada célula uma tarefa. Por exemplo, para uma solução onde temos duas máquinas e quatro tarefas, onde as tarefas dois e três estão alocadas na primeira máquina e as tarefas um e quatro na segunda, temos:
$
\begin{bmatrix}
2 & 3 \\
1 & 4
\end{bmatrix}
$

%\ifthenelse {\boolean{showComments}}{
%  \textbf{Resposta:}\\
%  Variáveis:\\
%AQUI DENTRO PODEM COLOCAR COMENTÁRIOS QUE NÃO %APARECERÃO NO PDF
%}



\end{document}
% Local Variables:
% auto-fill-function: do-auto-fill
% fill-column: 110
% mode-name: "LaTeX"
% TeX-PDF-mode: t
% End:

% LocalWords:  UFRGS Simplex Bland
